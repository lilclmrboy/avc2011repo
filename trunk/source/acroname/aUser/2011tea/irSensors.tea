/* ************************************************************************** */
/* IR sensor polling thread */

#include "avc2011.tea"
#include <aA2D.tea>

/*
  when IR_NUMBER_RANGERS == 2
	
  32767 / IR_NUMBER_RANGERS = 16383
	16383 / 512 = 31
	
	therefore,
	
	divider = (32767 / IR_NUMBER_RANGERS ) / 512
	
	simplifying,
	
	divider = (0x7FFF >> 9) / IR_NUMBER_RANGERS
	
	making it, 
	
	result = a2d * ((0x7FFF >> 9) / IR_NUMBER_RANGERS)
*/

/* ************************************************************************** */
/* Computes a scalar that is equal to the distance
 * Capped at 1000
 * At the closest distance, the sharp rangers is at 2.5V. Our A2D is 10-bit
 * over a 0-5V range. 
 */
int gp2dxx_magnitude(char index) {
	int result = 0;
	int reading = 0;
	
	// Take the reading.
	reading = aA2D_ReadInt(index);
	
	// If we are ever bigger the IR_MAX_THRESHOLD. Put a bird on it. 
	if (reading > IR_MAX_THRESHOLD) reading = IR_MAX_THRESHOLD;
	
	// If we are smaller then a small range
	if (reading < IR_MIN_THRESHOLD) reading = 0;
	
	// Read the result and scale it down
	// The Sharp IR rangers at most output 2.5V, which is an A2D reading of 512. 
	result = reading << (7 - IR_NUMBER_RANGERS);
		
	// Return the value with a distance approximation
	return (result / 100);
}

/* ************************************************************************** */
void main(char callingProcID)
{

	int magnitude = 0;
	int directionCosine = 0;
	int directionSine = 0;
	int Ux = 0;
	int Uy = 0;
	char id = IR_NUMBER_RANGERS;
	int index = IR_NUMBER_RANGERS;

#ifdef aDEBUG
	aCore_Sleep(5000);
	aPrint_String("irSensors launched.\n");
#endif

	while(1) {
	  
			// Move to the next sensor id value
			index--;
	
		// For each sensor, we do the following
		// 1.) Read the sensor
		// 2.) Calculate the X and Y force component
		// 3.) Aggregate all the X and Y forces
		// 4.) Write X and Y result to scratchpad
		
			// Walk through the sensors. we set the id here so we can 
			// scale the code very easily.
			// We can also build up the Ux and Uy components
			switch (index) {

				case 0: 
					id = IR_LEFT_ID;
					directionCosine = IR_LEFT_ANGLE_COSINE;
					directionSine = IR_LEFT_ANGLE_SINE;
					break;

				case 1: 
					id = IR_RIGHT_ID;
					directionCosine = IR_RIGHT_ANGLE_COSINE;
					directionSine = IR_RIGHT_ANGLE_SINE;
					break;	

				case 2: 
					id = IR_CENTER_ID;
					directionCosine = IR_CENTER_ANGLE_COSINE;
					directionSine = IR_CENTER_ANGLE_SINE;
					break;	
					
				default:
					// Write result to the scratchpad
					aPad_WriteInt(aSPAD_GP2_REPULSIVE_UX, Ux);
					aPad_WriteInt(aSPAD_GP2_REPULSIVE_UY, Uy);
					
					
#ifdef aDEBUG_IR
			aPrint_String("(Ux Uy):");
			aPrint_IntDec(Ux);
			aPrint_String(",");
			aPrint_IntDec(Uy);
			aPrint_Char('\n');
			aCore_Sleep(2000);
#endif					
					
					// Set the Ux and Uy values back to zero
					Ux = 0;
					Uy = 0;
					
					// Set the id back to the max number of sensors
					index = IR_NUMBER_RANGERS;
					
					break;
			}
		
			// Get the reading magnitude value 
			magnitude = gp2dxx_magnitude(id);
			
			if (id == IR_CENTER_ID) {
			  magnitude = magnitude >> 2;
			  
			  if (magnitude <= IR_CENTER_MIN_THRES)
			    magnitude = 0;
			}
			
			// Since we know that fixed positions of the sensors, we can just
			// hard code the resulting trig math fancyness. 
			// Keeping it simple. 
			  // Scale the result down to an integer value we can work with
			  Ux = -1 * magnitude * directionCosine + Ux;
			  Uy = -1 * magnitude * directionSine + Uy;
		
      
		// We don't want to swamp the processor
		aCore_Sleep(500);
		
	} // end of while loop
	
} // end of main
