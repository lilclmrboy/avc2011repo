/* ************************************************************************** */
/* IR sensor polling thread */

#include "avc2011.tea"
#include <aA2D.tea>

#define IR_MIN_THRESHOLD 50

// At a 30 degree angle from the straight ahead direction 
#define IR_LEFT_ID 0
#define IR_LEFT_ANGLE_COSINE 86
#define IR_LEFT_ANGLE_SINE 50

// At a -30 (aka 270) degree angle from the straight ahead direction 
#define IR_RIGHT_ID 1
#define IR_RIGHT_ANGLE_COSINE 86
#define IR_RIGHT_ANGLE_SINE -50

#define IR_NUMBER_RANGERS 2

/*
  when IR_NUMBER_RANGERS == 2
	
  32767 / IR_NUMBER_RANGERS = 16383
	16383 / 512 = 31
	
	therefore,
	
	divider = (32767 / IR_NUMBER_RANGERS ) / 512
	
	simplifying,
	
	divider = (0x7FFF >> 9) / IR_NUMBER_RANGERS
	
	making it, 
	
	result = a2d * ((0x7FFF >> 9) / IR_NUMBER_RANGERS)
*/

/* ************************************************************************** */
/* Computes a scalar that is equal to the distance
 * Capped at 1000
 * At the closest distance, the sharp rangers is at 2.5V. Our A2D is 10-bit
 * over a 0-5V range. 
 */
int gp2dxx_magnitude(char index) {
	int result = 0;
	int reading = 0;
	
	// Take the reading.
	reading = aA2D_ReadInt(index);
	
	// Read the result and scale it down
	// The Sharp IR rangers at most output 2.5V, which is an A2D reading of 512. 
	result = reading << 5;

	if (result > 0x4000) result = 0x4000;
		
	// Return the value with a distance approximation
	return (result / 100);
}

/* ************************************************************************** */
void main(char callingProcID)
{

	int magnitude = 0;
	int directionCosine = 0;
	int directionSine = 0;
	int Ux = 0;
	int Uy = 0;
	char id = 0;

#ifdef aDEBUG
	aCore_Sleep(5000);
	aPrint_String("irSensors launched.\n");
#endif

	while(1) {
	
		// For each sensor, we do the following
		// 1.) Read the sensor
		// 2.) Calculate the X and Y force component
		// 3.) Aggregate all the X and Y forces
		// 4.) Write X and Y result to scratchpad
		//if (aPad_ReadChar(aSPAD_GP2_IR_PROCESS_ENABLE)) {
		
			// Walk through the sensors. we set the id here so we can 
			// scale the code very easily.
			// We can also build up the Ux and Uy components
			switch (id) {

				case 0: 
					id = IR_LEFT_ID;
					directionCosine = IR_LEFT_ANGLE_COSINE;
					directionSine = IR_LEFT_ANGLE_SINE;
					break;

				case 1: 
					id = IR_RIGHT_ID;
					directionCosine = IR_RIGHT_ANGLE_COSINE;
					directionSine = IR_RIGHT_ANGLE_SINE;
					break;	

				default:
					// Write result to the scratchpad
					aPad_WriteInt(aSPAD_GP2_REPULSIVE_UX, Ux);
					aPad_WriteInt(aSPAD_GP2_REPULSIVE_UY, Uy);
					
					// Set the Ux and Uy values back to zero
					Ux = 0;
					Uy = 0;
					
					// Set the id back to 0
					id = 0;
					
					break;
			}
		
			// Get the reading magnitude value 
			magnitude = gp2dxx_magnitude(id);
			
			// Since we know that fixed positions of the sensors, we can just
			// hard code the resulting trig math fancyness. 
			// Keeping it simple. 
			// Scale the result down to an integer value we can work with
			Ux = -1 * magnitude * directionCosine + Ux;
			Uy = -1 * magnitude * directionSine + Uy;
			
#ifdef aDEBUG_IRPOLLING
			aPrint_String("(id Mag Ux Uy):");
			aPrint_IntDec(id);
			aPrint_String(",");
			aPrint_IntDec(magnitude);
			aPrint_String(",");
			aPrint_IntDec(Ux);
			aPrint_String(",");
			aPrint_IntDec(Uy);
			aPrint_Char('\n');
			aCore_Sleep(2000);
#endif

			// Move to the next sensor id value
			id++;
		
		//} // end if reading values
		
		// We don't want to swamp the processor
		aCore_Sleep(aSLICE);
		
	} // end of while loop
	
} // end of main
