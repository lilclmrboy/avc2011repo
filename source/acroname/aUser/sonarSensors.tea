/* ************************************************************************** */
/* Devantech sonar sensor polling thread */

#include "avc2011.tea"
#include <aSRF08.tea>

#define SONAR_MIN_THRESHOLD 20

// The 0 degree angle is the straight ahead reading for the robot
// Integer scaled cosine and sine values
// for example, cosine(pi/4) * 10 = 70

// At a 0 degree angle from the straight ahead direction 
#define SONAR_LEFT_ID 0
#define SONAR_LEFT_ADDR (char) 0xE2
#define SONAR_LEFT_ANGLE_COSINE 100
#define SONAR_LEFT_ANGLE_SINE 0

#define aSRF0X_MAX_DISTANCE_CM 60


/* ************************************************************************** */
void main(char callingProcID)
{

	int magnitude = 0;
	int directionCosine = 0;
	int directionSine = 0;
	int Ux = 0;
	int Uy = 0;
	char id = 0;
	unsigned char addr = 0;

#ifdef aDEBUG
	aCore_Sleep(5000);
	aPrint_String("sonarSensors launched.\n");
#endif

	while(1) {
	
		// For each sensor, we do the following
		// 1.) Read the sensor
		// 2.) Calculate the X and Y force component
		// 3.) Aggregate all the X and Y forces
		// 4.) Write X and Y result to scratchpad
		
			// Walk through the sensors. we set the id here so we can 
			// scale the code very easily.
			// We can also build up the Ux and Uy components
			switch (id) {
			
				case 0: 
					id = SONAR_LEFT_ID;
					directionCosine = SONAR_LEFT_ANGLE_COSINE;
					directionSine = SONAR_LEFT_ANGLE_SINE;
					addr = SONAR_LEFT_ADDR;
					break;
			
				default:
					aPad_WriteInt(aSPAD_GP2_SONAR_REPULSIVE_UX, Ux);
					aPad_WriteInt(aSPAD_GP2_SONAR_REPULSIVE_UY, Uy);
					
					// Set the Ux and Uy values back to zero
					Ux = 0;
					Uy = 0;
					
					// Set the id back to 0
					id = 0;
					
					break;
			}
		
			// limit ir sensor reading to ~60cm (aSRF0X_MAX_DISTANCE_CM) and provide
			// the negation of the distance to the force calculation
			magnitude = aSRF08_RangeInt(addr, aSRF08_CM);
			if(magnitude > aSRF0X_MAX_DISTANCE_CM) {
				magnitude = 0;
			}
			else {
				// Calc the reading magnitude value
				// y = -x + b 
				magnitude = -1*aSRF08_RangeInt(addr, aSRF08_CM) + aSRF0X_MAX_DISTANCE_CM;
			}
			
			// Since we know that fixed positions of the sensors, we can just
			// hard code the resulting trig math fancyness. 
			// Keeping it simple. 
			// Scale the result down to an integer value we can work with
			Ux = ((-1*magnitude * directionCosine)/10) + Ux;
			Uy = ((-1*magnitude * directionSine)/10) + Uy;
			
#ifdef aDEBUG
			aPrint_String("(id Mag Ux Uy):");
			aPrint_IntDec(id);
			aPrint_String(",");
			aPrint_IntDec(magnitude);
			aPrint_String(",");
			aPrint_IntDec(Ux);
			aPrint_String(",");
			aPrint_IntDec(Uy);
			aPrint_Char('\n');
			aCore_Sleep(2000);
#endif

			// Move to the next sensor id value
			id++;
		
		// We don't want to swamp the processor
		aCore_Sleep(aSLICE);
		
	} // end of while loop
	
} // end of main
