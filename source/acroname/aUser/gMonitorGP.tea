/* ************************************************************************** */
/* GP 2.0 monitoring file */

#include "avc2011.tea"
#include "rc.tea"


/* ************************************************************************** */
/* 1.) Configure scatchpad values
 */
void init() {

	/* Configure scratchpad values */
	aPad_WriteChar(aSPAD_GP2_GPMONITOR_SHUTDOWN,0);

	/* Zero out other placehoder readings */
	aPad_WriteInt(aSPAD_GP2_REPULSIVE_UX,0);
	aPad_WriteInt(aSPAD_GP2_REPULSIVE_UY,0);
  aPad_WriteInt(aSPAD_GP2_SONAR_REPULSIVE_UX,0);
  aPad_WriteInt(aSPAD_GP2_SONAR_REPULSIVE_UY,0);
	aPad_WriteInt(aSPAD_GP2_GPS_MIN, 0);
	aPad_WriteInt(aSPAD_GP2_GPS_SEC, 0);
	aPad_WriteInt(aSPAD_GP2_GPS_LAT, 0);
	aPad_WriteInt(aSPAD_GP2_GPS_LAT+2, 0);
	aPad_WriteInt(aSPAD_GP2_GPS_LAT+4, 0);
  aPad_WriteInt(aSPAD_GP2_GPS_LON, 0);
	aPad_WriteInt(aSPAD_GP2_GPS_LON+2, 0);
	aPad_WriteInt(aSPAD_GP2_GPS_LON+4, 0);
	aPad_WriteInt(aSPAD_GP2_GPS_SPD, 0);
	aPad_WriteInt(aSPAD_GP2_GPS_SPD+2, 0);
	aPad_WriteInt(aSPAD_GP2_GPS_HD, 0);
	aPad_WriteInt(aSPAD_GP2_GPS_HD+2, 0);
	aPad_WriteInt(aSPAD_GP2_CMPS_HD, 0);
  aPad_WriteInt(aSPAD_GP2_ACC_X, 0);
  aPad_WriteInt(aSPAD_GP2_ACC_Y, 0);
  aPad_WriteInt(aSPAD_GP2_ACC_Z, 0);

	/* Set other non zero defaults */
	aBus_WritePadInt(aMOTO_MODULE, aSPAD_MO_MOTION_RAMPACC_TIME, aACCELRATION_TIME);	
	aBus_WritePadInt(aMOTO_MODULE, aSPAD_MO_MOTION_RCENABLE, 0);
	aBus_WritePadInt(aMOTO_MODULE, aSPAD_MO_MOTION_RCSET_RIGHT, 0);
	aBus_WritePadInt(aMOTO_MODULE, aSPAD_MO_MOTION_RCSET_LEFT, 0);
	
}

/* ************************************************************************** */
void shutdown() {

	aPrint_String("gMonitorGP shutdown");

	/* Clean up billy! */
	aPrint_String("irSensors shutdown");
	aPrint_Char('\n');
	aCore_Sleep(1000);

	aMulti_Kill(aIR_POLLING_GP2_PROCESS);
	
	/* Clean up billy! */
	aPrint_String("sonarSensors shutdown");
	aPrint_Char('\n');
	aCore_Sleep(1000);

	aMulti_Kill(aSONAR_POLLING_GP2_PROCESS);	

	/* Clean up billy! */
	aPrint_String("locSensors shutdown");
	aPrint_Char('\n');
	aCore_Sleep(1000);

	aMulti_Kill(aLOC_POLLING_GP2_PROCESS);	

	/* Clean up billy! */
	aPrint_String("motionUpdate shutdown");
	aPrint_Char('\n');
	aCore_Sleep(1000);

	aBus_Multi_Kill(aMOTO_MODULE, aMOTION_UPDATING_MO_PROCESS);
	
	/* stall for a second to let all the op codes return */
  aCore_Sleep(1000);
	
}

/* ************************************************************************** */
void main()
{

	/* Values to measure the digital pulse timing */
	int RCRight = 0;
	int RCLeft = 0;
	int RCRightLast = 0;
	int RCLeftLast = 0;
	
	char bDebugInfo = 1;
	char bRCModeEnabled = 0;
	char bRCModeDisabled = 1;

	/* Initailize the system */
	init();

	aPrint_String("gMonitorGP launched");
	aPrint_Char('\n');
	aCore_Sleep(2000);
	aPrint_Char('\n');
	
	/* Spawn the IR polling thread */
	aMulti_Spawn(aIR_POLLING_GP2_SLOT, aIR_POLLING_GP2_PROCESS);

	/* Spawn the location polling thread */
	//aMulti_Spawn(aLOC_POLLING_GP2_SLOT, aLOC_POLLING_GP2_PROCESS);
	
	/* Spawn the motion updating thread */
	// Write a aBus_Multi_Spawn function. Add this to the aBus library
	aBus_Multi_Spawn(aMOTO_MODULE, aMOTION_UPDATING_MO_SLOT,
										aMOTION_UPDATING_MO_PROCESS);
	
	// Do monitor relevant things. Bookkeeping, coordinating, etc. 
	while (!aPad_ReadChar(aSPAD_GP2_GPMONITOR_SHUTDOWN)) {
	
		// Debugging for servo pulse measurement to use RC remote control over
		// riding for motion testing.	
		if (bDebugInfo) {
			aPrint_String("RC remote monitor launched.");
			aPrint_Char('\n');
			aCore_Sleep(1000);
			bDebugInfo = 0;
		}

		// RC remote manual over ride
		if (read_RCEnable() > aRC_ENABLE_THRESHOLD) {
		
			// Read the pulse timer for the digital input pins
			RCLeft = read_LeftRC();
			RCLeft = rcWindow(RCLeft);
			RCRight = read_RightRC();
			RCRight = rcWindow(RCRight);
			
			// Enable the RC over ride on the Moto module
			// This should reduce the number of scratchpad writes to the Moto
			if (!bRCModeEnabled) {
				aBus_WritePadInt(aMOTO_MODULE, aSPAD_MO_MOTION_RCENABLE, 1);
				bRCModeEnabled = 1;
				bRCModeDisabled = 0;
			}
			
		} else {
		
			RCLeft = 0;
			RCRight = 0;
			
			// Disable the RC over ride on the Moto module
			// This should reduce the number of scratchpad writes to the Moto
			if (!bRCModeDisabled) {
				aBus_WritePadInt(aMOTO_MODULE, aSPAD_MO_MOTION_RCENABLE, 0);
				bRCModeEnabled = 0;
				bRCModeDisabled = 1;
			}			
		}

		// Update the scratchpad on the moto
		// This should reduce the number of scratchpad writes to the Moto
		if (RCRight != RCRightLast) {
			aBus_WritePadInt(aMOTO_MODULE, aSPAD_MO_MOTION_RCSET_RIGHT, RCRight);
			RCRightLast = RCRight;
		}
		
		// This should reduce the number of scratchpad writes to the Moto
		if (RCLeft != RCLeftLast) {
			aBus_WritePadInt(aMOTO_MODULE, aSPAD_MO_MOTION_RCSET_LEFT, RCLeft);
			RCLeftLast = RCLeft;
		}
		
		/* stall for a timeslice */
		aCore_Sleep(aSLICE);
	
	} // end pseudo infinite while loop
	
	// clean up and shutdown
	shutdown();
	
} // end of main
